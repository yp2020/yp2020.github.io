Redis 是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来来保证数据持久化，当Redis 重启之后，通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。

Redis 支持 2 种持久化机制，

1.  RDB 方式 也就是快照
2. AOF 方式

## RDB 方式

Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。

创建快照之后，可以对快照进行 备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（ Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。 

### 触发机制

#### 手动触发:   

`save` 命令和 `bgsave`  命令,

- `save`  命令会阻塞当前服务器,直到 RDB 过程完成为止。
- `bgsave`  Redis 进程使用操作系统的多进程机制来实现快照持久化，调用 `glibc` 函数  fork 一个子进程，然后将快照持久化操作完全交给子进程去处理，而父进程则继续处理客户端请求，阻塞只发生在 fork 阶段，在这个过程中，子进程能够看到的内存中的数据在子进程产生的一瞬间就固定下来了，再也不会改变。

#### 自动触发 

Redis  内部存在自动触发的 RDB 持久化机制 ，例如：

1. 使用 save 相关配置

   >save m n   在 m 秒内数据集中存在 n 次修改时，自动触发 bgsave 

2. 如果从节点执行全量复制操作，主节点自动执行 `bgsave` 生成 RDB 文件，并发送给从节点进行数据同步。
3. 执行 `debug reload` 命令重新加载 `Redis ` 时，也会自动触发 save 操作。
4. 默认情况下，执行 `shutdown` 命令时，如果没有开启 AOF 持久化功能，则自动执行 `bgsave ` 

### 流程 

首先看这张图 

![image-20220308164123064](https://wayne6.oss-cn-hangzhou.aliyuncs.com/img/image-20220308164123064.png)

1. 执行命令， Redis 父进程判断当前是否存在正在执行的子进程，如 RDB/AOF 子进程，如果存在 `bgsave`

   命令直接返回。

2. 父进程执行 fork 操作创建子进程，fork操作过程中父进程会阻塞。

3. 父进程 fork 完成后，bgsave 命令返回 Background saving started 信息 并不再阻塞父进程，父进程可以继续响应其他命令。 

4. 子进程创建 RDB 文件，根据父进程内存生成临时快照文件，完成后 对原有文件进行原子替换。

5. 进程发送信号给父进程表示完成，父进程更新统计信息。

### 配置

快照持久化的方式默认是开启的，会产生一个 `dump.rdb` 文件，这个文件就是备份下来的文件，

当 Redis 启动时，会自动去加载 该 rdb 文件，从该文件中恢复数据。

具体的配置信息，在 配置文件中：

1. 快照的频率

	> save 900 1    # 900 秒内至少有一个键被修改，则进行修改

2. 快照执行出错后，是否继续处理客户端命令

	> stop-writes-on-bgsave-error yes

3. 是否对快照文件进行压缩

	> rdbcompression yes

4. 表示生成的快照文件名与文件位置

  > dbfilename dump.rdb
  > dir ./

### 优缺点 

#### 优点：

1. RDB 是一个紧凑压缩的二进制文件，代表 Redis 在某个时间点上的数据快照。**非常适用于备份，全量复制**等场景。比如每6小时执行bgsave备份， 并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），用于灾难恢复。 
2. Redis 加载 RDB 恢复数据**远远快于**AOF 的方式。 

#### 缺点：

1.  RDB 方式 数据 **没办法做到实时持久化/秒级持久化** 。因为 bgsave 每次运行都要执行 fork 操作创建子进程，属于重量级操作，频繁执行成本过高。 
2. **老版本无法兼容新版本 RDB 格式** ：RDB 文件使用特定二进制格式保存，Redis 版本演进过程中有多个格式的 RDB 版本，存在老版本Redis服务无法兼容新版RDB格式的问题。

## AOF 

append only file 

以独立日志的方式记录 **每次写命令**，重启时再重新执行 AOF 文件中的命令，相当于把数据还原了。

主要作用就是解决了数据持久化的实时性。开启 AOF 持久化之后，每一条更改 Redis 中的数据的命令都会被写入AOF 文件中。具体的同步方式由 参数 

### 使用 AOF 

默认情况下，AOF 是关闭的，需要手动开启，同时为了避免快照备份影响，最好关闭快照备份。

1. 开启 aof 配置 

   > appendonly yes 

2. AOF 文件名 

   > appendfilename "appendonly.aof"


### AOF 的工作流程 

![image-20220308193140640](https://wayne6.oss-cn-hangzhou.aliyuncs.com/img/image-20220308193140640.png)

1. append 命令写入 ,在命令执行完后，将所有的写入命令 **追加写** 到 aof_buf (缓冲区)中。
2.  sync 文件同步， Redis 会启动一个线程将 缓冲区的数据 根据 对应的策略写到磁盘中（也就是同步操作）。
3. rewrite  文件重写 ，随着 AOF 文件越来越大，需要定期对 AOF文件进行重写，达到压缩的目的
4. load  重启加载，当服务器重启时，可以加载 AOF 文件进行数据恢复。



#### 1. 命令写入

AOF 文件是一个文本文件，采用的是 RESP 协议。

采用该协议的原因如下 

1. 文本协议具有好的兼容性
2. 开启 AOF 之后，所有的写入命令都包含追加操作，直接采用协议格式，避免了二次处理开销
3. 文本协议具有可读性，方便直接修改和处理。

为什么每次都把命令追加到 aof_buf 中？

1.  Redis 使用单线程响应命令，如果每次写 AOF 文件命令都直接追加到磁盘，那么性能完全取决于当前硬盘的负载。
2. Redis 可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡。

#### 2. 文件同步

Redis 有多种 AOF 缓冲区同步文件策略，由参数 appendfsync 控制

| 可选参数                     | 说明                                                         | 说明                                                         |
| ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| always <br />每条命令都执行  | 命令写入 aof_buf 后调用系统 fsync 操作同步到 AOF 文件，fsync 完成后，线程返回 | 每次写入都要同步 AOF 文件，影响性能                          |
| everysec <br />每秒一次      | 命令写入 aof_buf 后调用系统 write 操作，write 完成后，线程返回，fsync 同步文件操作由专门的线程每秒调用一次。 | 默认配置，理论上，只有系统在突然宕机的情况下丢失 1s 的数据 。 |
| no<br />从不存盘，靠操作系统 | 命令写入 aof_buf 后调用系统 write 操作 ，不对 AOF 文件做同步，同步硬盘由操作系统负责，通常同步周期 30秒 。 | 由于操作系统每次同步AOF文件的周期不可控，而且会加大每次同步硬盘的数据量，虽然提升了性能，但数据安全性无法保证。 |

- write 操作会触发延迟写（delayed write）机制。Linux在内核提供页缓冲区用来提高硬盘IO性能。write操作在写入系统缓冲区后直接返回。同步硬盘操作依赖于系统调度机制，
- fsync 针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将 阻塞直到写入硬盘完成后返回，保证了数据持久化。



#### 3. 重写机制 

AOF 重写机制是为了压缩文件的体积，它是把 Redis 进程内的数据转化为写命令同步到 新 AOF 文件的过程。

重启的 AOF 文件为什么可以变小？

1. 进程内超时的数据不再写入文件
2. 重写使用进程内数据直接生成，新的 AOF 文件中只有最终数据的写入命令。
3. 多条写命令可以合并成 1 个，但是为了防止单条命令过大造成客户端缓冲区溢出，所以对于list、set、hash、zset等类型操作，以64个元素为界拆分为多条。

AOF 重写的两个目的：

1. 降低文件占用空间
2. 更小的 AOF 文件的加载速度更快。

##### 重写过程的触发 

1. 手动触发：直接调用 bgrewriteaof 命令。

2. 自动触发 
   - 运行 AOF 重写时， AOF 文件的最小体积，如果之前没有重写过，则以启动时的 aof 大小为根据，同时要求这个文件大小至少为 64 M
   
     > auto-aof-rewrite-min-size 64mb  
   
   
   
   - 当目前 aof 文件大小 超过 上一次重写时的 aof 文件大小 的百分之多少的时候，再次进行重写
   
     > auto-aof-rewrite-percentage 100  
   
   ​          当前文件 AOF 空间 aof-current-size 
   
   ​         上一次重写 AOF 文件空间 aof-base-size
   
   ​        当  aof-current-size > auto-aof-rewrite-min-size  当前文件大小 超过 规定的最小体积 
   
   ​       并且 （aof_current_size **-** aof_base_size）/aof_base_size >=auto-aof-rewritepercentage
   
   ​    发生重写。
   
   
   
   
   
##### AOF 文件重写的运行流程

![image-20220308200705880](https://wayne6.oss-cn-hangzhou.aliyuncs.com/img/image-20220308200705880.png)

1. 执行 AOF 重写请求，如果当前进程正在执行 AOF 重写 ，则该请求不执行

   如果当前进程正在执行 bgsave 操作，重写命令延迟到 bgsave 完成之后再 执行

2. 父进程 fork 一个进程来对 AOF 进行重写，这个过程中，主线程阻塞。

3.  - 主进程 fork 操作完成后，继续响应其他命令。所有修改命令依然写入 AOF 缓冲区并根据 appendfsync 策略同步到硬盘，保证原有AOF机制正确 性。 

   - 由于fork操作运用写时复制技术，子进程只能共享fork操作时的内存数据。但是父进程依然是响应命令的，Redis使用“ **重写缓冲区 **保存这部 分新数据，防止新AOF文件生成期间丢失这部分数据。 
   
     也就是说，在子进程重写AOF 文件的过程中，会存在两个缓冲区，然后数据也会放入这两个缓冲区。
   
4. 子进程根据内存快照，按照命令合并规则写入到新的AOF文件。每 次批量写入硬盘数据量由配置` aof-rewrite-incremental-fsync`控制，默认为 32MB，防止单次刷盘数据过多造成硬盘阻塞。

5. - 新AOF文件写入完成后，子进程发送信号给父进程，父进程更新统计信息。
   - 父进程把 AOF **重写缓冲区** 的数据写入到新的AOF文件。 
   - 使用新AOF文件替换老文件，完成AOF重写。



#### 4. 重启加载

![image-20220308201320927](https://wayne6.oss-cn-hangzhou.aliyuncs.com/img/image-20220308201320927.png)



## 阻塞控制 

持久化 阻塞主线程有 2 个场景，fork 阻塞 和 AOF 追加阻塞 。

### AOF 阻塞控制

当开启AOF持久化时，常用的同步硬盘的策略是everysec，用于平衡性 能和数据安全性。对于这种方式，Redis使用另一条线程每秒执行 fsync 同步硬盘。当系统硬盘资源繁忙时，会造成Redis主线程阻塞。

![image-20220308201743367](https://wayne6.oss-cn-hangzhou.aliyuncs.com/img/image-20220308201743367.png)

阻塞流程分析：

1. 主线程负责写入AOF缓冲区
2. AOF线程负责每秒执行一次同步磁盘操作，并记录最近一次同步时 间。
3. 主线程负责对比上次AOF同步时间： 
   - 如果距上次同步成功时间在2秒内，主线程直接返回。 
   - 如果距上次同步成功时间超过2秒，主线程将会阻塞，直到同步操作完成。 

通过对AOF阻塞流程可以发现两个问题： 

1. everysec配置最多可能丢失2秒数据，不是1秒。 
2. 如果系统 fsync 缓慢，将会导致 Redis 主线程阻塞影响效率。

## 持久化机制的优化

可以考虑混合持久化 ，也就是两个都开启，这种情况下，会优先加载 AOF 文件。

## 总结

1. 如果 Redis 只是做缓存服务器，两个都行
2. 如果同时开启两种持久化方式时，Redis 重启时会优先载入 AOF 文件，因为  aof 保存的数据集更完整。但是重载入 rdb 文件比重载 aof 文件更快，也更推荐使用 rdb
3. 要求 aof 文件至少要大于 64M ，因为 rewrite 文件会带来一系列的 IO。所以文件最好尽量大一些。
3. AOF通过追加写命令到文件实现持久化，通过appendfsync参数可以 控制实时/秒级持久化。因为需要不断追加写命令，所以AOF文件体积逐渐 变大，需要定期执行重写操作来降低文件体积。
3. 子进程执行期间使用copy-on-write机制与父进程共享内存，避免内 存消耗翻倍。AOF重写期间还需要维护重写缓冲区，保存新的写入命令避免 数据丢失。
3. 持久化阻塞主线程场景有：fork阻塞和AOF追加阻塞。fork阻塞时间 跟内存量和系统有关，AOF追加阻塞说明硬盘资源紧张。
